# Neo4j Traversals

This repository contains the code for a Neo4j unmanaged extension demonstrating a performance regression in the 
traversals between Neo4j 2.2 and 2.3, probably due to the simplification of the cache.

## Installation

1. Clone this repository
1. Build it locally using Maven and a 1.7 JDK:

        mvn clean package
    
1. Copy the resulting artifact to the `plugins` directory in your Neo4j installation:

        cp target/traversal-perfs-1.0-SNAPSHOT.jar /path/to/neo4j/plugins/
        
1. Configure Neo4j to load the unmanage extension by adding in `conf/neo4j-server.properties`:

        org.neo4j.server.thirdparty_jaxrs_classes=com.ekino.neo4j.traversal=/traversal-perfs

## Usage

1. Start your Neo4j instance, if possible with an empty database:

        bin/neo4j start
        
1. Populate the database with a traversable tree.
        
        curl localhost:7474/traversal-perfs/populate
        
    The tree consists of a root node (with the `:Root` and `:A` labels), connected to `:B` nodes through a `HAS_B`
    relationship, connected to more `:A` nodes through a `HAS_A` relationship. By default, the tree has a depth of 5 
    such "levels", and a fanout factor of 4 (the number of children nodes for a parent node), i.e. 1398101 nodes.
    Those parameters can be modified using query parameters, "depth" and "fanout":
     
        curl localhost:7474/traversal-perfs/populate?depth=8&fanout=2
        
     The database needs to be emptied before a new tree can be generated.
        
1. Warm-up the JVM.
        
        # Default breadth-first traversal mode
        ab -c 1 -n 100 localhost:7474/traversal-perfs/traverse > /dev/null 2>&1
        # or explicit depth-first traversal mode
        ab -c 1 -n 100 'localhost:7474/traversal-perfs/traverse?depthFirst=' > /dev/null 2>&1

1. Measure the response time.

        # Default breadth-first traversal mode
        ab -c 1 -n 100 localhost:7474/traversal-perfs/traverse
        # or explicit depth-first traversal mode
        ab -c 1 -n 100 'localhost:7474/traversal-perfs/traverse?depthFirst='

## Traversal implementation

The code only has 5 source files, and the most relevant part is 
[`TrueBNodesCounter`](src/main/java/com/ekino/neo4j/traversal/TrueBNodesCounter.java) which
implements a traversal using custom `Evaluator` and `PathExpander`, based on the core Neo4j API: `Node::hasLabel`,
`Node::getProperty`, `Node::getRelationships`.

Profiling (using Yourkit) shows that the cost of all these API calls has increased between 2.1 and 2.3, and that more
garbage is generated by a request.

## Results

The times are in milliseconds.

<table>
  <tr>
    <th>Version</th>
    <th colspan="6">Neo4j Enterprise 2.2.7</th>
    <th colspan="6">Neo4j Enterprise 2.3.2</th>
  </tr>
  <tr>
    <th>Traversal mode</th>
    <th colspan="3">Breadth-First</th>
    <th colspan="3">Depth-First</th>
    <th colspan="3">Breadth-First</th>
    <th colspan="3">Depth-First</th>
  </tr>
  <tr>
    <th>Heap in MB</th>
    <th>1024</th>
    <th>2048</th>
    <th>4096</th>
    <th>1024</th>
    <th>2048</th>
    <th>4096</th>
    <th>1024</th>
    <th>2048</th>
    <th>4096</th>
    <th>1024</th>
    <th>2048</th>
    <th>4096</th>
  </tr>
  <tr>
    <td>Mean</td>
    <td>6616</td>
    <td>3441</td>
    <td>2045</td>
    <td>2229</td>
    <td>2209</td>
    <td>1276</td>
    <td>2771</td>
    <td>2500</td>
    <td>2465</td>
    <td>1544</td>
    <td>1543</td>
    <td>1540</td>
  </tr>
  <tr>
    <td>50%</td>
    <td>6308</td>
    <td>3281</td>
    <td>2022</td>
    <td>2228</td>
    <td>2208</td>
    <td>1277</td>
    <td>2748</td>
    <td>2487</td>
    <td>2443</td>
    <td>1549</td>
    <td>1517</td>
    <td>1547</td>
  </tr>
  <tr>
    <td>90%</td>
    <td>8520</td>
    <td>3823</td>
    <td>2296</td>
    <td>2406</td>
    <td>2415</td>
    <td>1391</td>
    <td>2981</td>
    <td>2672</td>
    <td>2674</td>
    <td>1679</td>
    <td>1690</td>
    <td>1693</td>
  </tr>
  <tr>
    <td>95%</td>
    <td>8820</td>
    <td>5268</td>
    <td>2353</td>
    <td>2454</td>
    <td>2488</td>
    <td>1424</td>
    <td>3145</td>
    <td>2773</td>
    <td>2709</td>
    <td>1711</td>
    <td>1727</td>
    <td>1716</td>
  </tr>
  <tr>
    <td>Max</td>
    <td>10591</td>
    <td>5807</td>
    <td>2856</td>
    <td>2485</td>
    <td>2795</td>
    <td>1513</td>
    <td>3722</td>
    <td>3321</td>
    <td>2936</td>
    <td>1882</td>
    <td>1771</td>
    <td>1757</td>
  </tr>
</table>

### Configurations

MacBook Pro Core i7 2.2 GHz, 16 GB

Oracle 64-bit JDK 1.8.0_74

`data/graph.db` takes 402 MB.

    dbms.pagecache.memory=500m
    
Note that because of the removal of the object cache, Neo4j 2.3 needs (much) less memory. I did run the same benchmark
with init/max heap parameters of 1024/1024, 2048/2048 and 2048/4096, and it didn't change the performance of 2.3, which
is why I kept the minimal configuration.

Running with a JDK 7 or 8 gives similar results, as does using the G1 or CMS garbage collectors.

------

Licensed under the Apache License, Version 2.0
